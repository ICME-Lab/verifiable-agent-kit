# Verifiable Agent Kit

A production-ready framework for privacy-preserving AI agents with real zero-knowledge proofs, multi-chain verification, and automated USDC transfers. Build trustless, verifiable compute applications using natural language commands.

## 🚀 Key Features

### Core Capabilities
- **Real Zero-Knowledge Proofs** - Generate cryptographic proofs using zkEngine (Nova → Groth16 SNARKs)
- **Multi-Chain Verification** - Deploy and verify proofs on Ethereum Sepolia and Solana Devnet
- **Automated USDC Transfers** - Real conditional transfers via Circle API based on proof verification
- **OpenAI-Powered Workflows** - GPT-4o integration for intelligent natural language parsing
- **Real-Time WebSocket UI** - Live tracking of proof generation, verification, and transfers
- **No Simulations** - Everything is real: proofs, blockchain transactions, and USDC transfers

### Supported Proof Types
1. **KYC Compliance** - Prove identity verification without revealing personal data
2. **Location Verification** - Prove geographic location within constraints  
3. **AI Content Authentication** - Verify content was generated by specific AI providers

### Latest v4.2 Features
- **OpenAI Workflow Parser** - Intelligent command understanding with GPT-4o
- **Enhanced UI** - Cleaner design with improved proof cards and status indicators
- **Proof History Table** - View and verify all generated proofs with on-chain status
- **Unique Commitments** - Timestamp-based proof uniqueness prevents replay attacks
- **Improved Solana Support** - Fixed PDA issues for multiple verifications
- **Real-time Status Updates** - Live progress tracking for all operations

## 🏗️ Architecture

```
┌─────────────────────┐     ┌──────────────────────┐     ┌─────────────────────┐
│   Frontend UI       │────▶│  Rust WebSocket      │────▶│ zkEngine Binary     │
│  (Real-time WS)     │◀────│  Server (Port 8001)  │◀────│ (Nova → Groth16)    │
└─────────────────────┘     └──────────────────────┘     └─────────────────────┘
         │                           │                             │
         ▼                           ▼                             ▼
┌─────────────────────┐     ┌──────────────────────┐     ┌─────────────────────┐
│ Blockchain Wallets  │     │ Python AI Service    │     │   Circle API        │
│ • MetaMask (ETH)    │     │ • OpenAI GPT-4o     │     │ • Real USDC         │
│ • Phantom (SOL)     │     │ • Workflow Parser    │     │ • Sandbox Network   │
└─────────────────────┘     └──────────────────────┘     └─────────────────────┘
```

## 💡 Example Commands

### Simple Verification
```
"Generate a KYC proof and verify it locally"
```

### Blockchain Verification with Transfer
```
"Generate KYC proof for Alice, verify on Ethereum, and if verified transfer 0.02 USDC to Bob on Solana"
```

### Multi-Person Conditional Workflow
```
"If Alice is KYC verified send her 0.05 USDC on Solana and if Bob is KYC verified send him 0.03 USDC on Ethereum"
```

### Location-Based Transfer
```
"Generate location proof for NYC, verify on Solana, then transfer 1 USDC to alice"
```

### Complex Multi-Step Workflow
```
"Create KYC proof, verify on chain, then check AI content proof, and if both valid send 5 USDC"
```

## 🔧 Installation

1. **Clone the repository**
```bash
git clone https://github.com/hshadab/verifiable-agentkit.git
cd verifiable-agentkit
```

2. **Install dependencies**
```bash
# Node.js dependencies
npm install

# Python dependencies
pip install -r requirements.txt

# Build Rust server
cargo build --release
```

3. **Configure environment**
```bash
cp .env.example .env
```

Edit `.env` with your credentials:
```env
# AI Services
OPENAI_API_KEY=your_openai_api_key

# Circle API (for USDC transfers)
CIRCLE_API_KEY=your_circle_api_key
CIRCLE_ETH_WALLET_ID=your_ethereum_wallet_id
CIRCLE_SOL_WALLET_ID=your_solana_wallet_id

# zkEngine Path
ZKENGINE_BINARY=./zkengine_binary/zkEngine

# Optional: Custom ports
PORT=8001
CHAT_SERVICE_PORT=8002
```

## 🚀 Quick Start

1. **Start all services**
```bash
# Terminal 1: Rust WebSocket server
cargo run

# Terminal 2: Python AI service
python chat_service.py
```

2. **Open the UI**
Navigate to `http://localhost:8001`

3. **Connect your wallet**
- For Ethereum: MetaMask
- For Solana: Solflare (recommended for demo), Phantom, or Backpack

4. **Try a workflow**
Type a natural language command and watch the real-time execution!

## 🔐 Security & Privacy

- **Zero-Knowledge**: Proofs reveal verification without exposing underlying data
- **On-Chain Immutability**: Verification records permanently stored on blockchain
- **Unique Proofs**: Each proof includes timestamp-based uniqueness to prevent replay attacks
- **Direct Wallet Signing**: All blockchain operations require user approval
- **OpenAI Integration**: Secure API key handling with environment variables

## 📊 Real Components (No Simulations!)

### Proof Generation & Verification
- ✅ Real zkEngine binary execution
- ✅ Nova to Groth16 SNARK conversion
- ✅ Actual cryptographic proof files (~18MB each)
- ✅ Deterministic commitments with unique proof IDs

### Blockchain Integration
- ✅ **Ethereum**: Contract `0x1e8150050a7a4715aad42b905c08df76883f396f` on Sepolia
- ✅ **Solana**: Program `5VzkNtgVwarEGSLvgvvPvTNqR7qQQai2MZ7BuYNqQPhw` on Devnet
- ✅ Real transaction hashes viewable on block explorers

#### On-Chain Verification Details

**Ethereum Smart Contract (Sepolia)**
```solidity
// Simplified version of deployed contract
contract ProofVerifier {
    mapping(bytes32 => bool) public verifiedProofs;
    
    event ProofVerified(
        string indexed proofId,
        bytes32 indexed commitment,
        address indexed verifier,
        uint256 timestamp
    );
    
    function verifyProof(
        string memory proofId,
        bytes32 commitment,
        uint8 proofType
    ) public {
        require(!verifiedProofs[commitment], "Already verified");
        verifiedProofs[commitment] = true;
        emit ProofVerified(proofId, commitment, msg.sender, block.timestamp);
    }
}
```

**Solana Program (Devnet)**
```rust
// Deployed via Solana Playground
use anchor_lang::prelude::*;

#[program]
pub mod proof_verifier {
    use super::*;
    
    pub fn verify_proof(
        ctx: Context<VerifyProof>,
        proof_id: [u8; 32],
        commitment: [u8; 32],
        proof_type: u8,
        timestamp: i64,
    ) -> Result<()> {
        let proof_account = &mut ctx.accounts.proof_account;
        
        proof_account.proof_id = proof_id;
        proof_account.commitment = commitment;
        proof_account.proof_type = proof_type;
        proof_account.timestamp = timestamp;
        proof_account.verifier = ctx.accounts.verifier.key();
        proof_account.verified_at = Clock::get()?.unix_timestamp;
        
        emit!(ProofVerified {
            proof_id,
            commitment,
            verifier: ctx.accounts.verifier.key(),
            timestamp: proof_account.verified_at,
        });
        
        Ok(())
    }
}

#[account]
pub struct ProofAccount {
    pub proof_id: [u8; 32],
    pub commitment: [u8; 32],
    pub proof_type: u8,
    pub timestamp: i64,
    pub verifier: Pubkey,
    pub verified_at: i64,
}
```

Both contracts store proof verification data on-chain with:
- Unique proof ID
- Cryptographic commitment (hash of proof data)
- Proof type (KYC, Location, AI Content)
- Timestamp
- Verifier address

The Solana program uses PDAs (Program Derived Addresses) to ensure each proof can only be verified once per commitment.

### USDC Transfers
- ✅ Circle API Sandbox (real test network)
- ✅ Actual wallet addresses and transfer IDs
- ✅ Blockchain confirmations with transaction hashes
- ✅ Multi-blockchain support (ETH & SOL)

## 🛠️ Development

### Project Structure
```
verifiable-agentkit/
├── src/
│   ├── main.rs              # Rust WebSocket server
│   └── nova_groth16_converter.rs # SNARK conversion logic
├── chat_service.py          # Python AI orchestrator with OpenAI
├── parsers/
│   └── workflow/
│       ├── workflowExecutor.js   # Workflow execution engine
│       └── workflowParser.js     # Command parsing logic
├── static/
│   ├── index.html          # Frontend UI with real-time updates
│   ├── ethereum-verifier.js # ETH blockchain integration
│   └── solana-verifier.js  # SOL blockchain integration
├── circle/
│   └── circleHandler.js    # USDC transfer logic with Circle API
└── zkengine_binary/        # zkEngine executable and WASM proofs
    ├── zkEngine
    ├── prove_kyc.wat
    ├── prove_location.wat
    └── prove_ai_content.wat
```

### Key Technical Components

#### OpenAI Integration (NEW in v4.2)
- Uses GPT-4o for natural language understanding
- Automatic workflow type detection
- Parameter extraction from complex commands
- Error handling and retry logic

#### Proof Generation Flow
1. User command → OpenAI parsing
2. zkEngine execution with WASM
3. Nova proof generation
4. Groth16 SNARK conversion
5. Commitment creation with proof ID

#### Verification Flow
1. Local verification (2-5 seconds)
2. On-chain submission
3. Smart contract validation
4. Event emission & confirmation

## 🧪 Testing

```bash
# Test proof generation
node test-snark.js

# Test OpenAI workflow parsing
python test_openai_parser.py

# Test Circle transfers
node circle/test-circle-transfer.js

# Test full workflow via API
curl -X POST http://localhost:8002/chat \
  -H "Content-Type: application/json" \
  -d '{"message": "Generate KYC proof and verify on Ethereum"}'
```

## 📈 Performance

- Proof generation: ~15-30 seconds (depending on complexity)
- Local verification: ~2-5 seconds
- Blockchain verification: ~10-30 seconds (network dependent)
- USDC transfers: ~30-60 seconds for confirmation
- OpenAI parsing: ~1-2 seconds

## 🤝 Contributing

We welcome contributions! Areas of interest:
- Additional proof types (credit score, age verification, etc.)
- New blockchain integrations (Polygon, Arbitrum, etc.)
- Performance optimizations
- UI/UX enhancements
- Multi-language support

## 🐛 Troubleshooting

### Common Issues

1. **"Transaction already processed"** - Fixed in v4.2 with unique commitments
2. **Wallet connection issues** - Ensure you're on the correct network (Sepolia/Devnet). For Solana, Solflare wallet is recommended
3. **Transfer failures** - Check Circle wallet balance and API credentials
4. **OpenAI errors** - Verify API key and check rate limits

### Debug Mode
- Click the debug toggle in the UI for detailed logs
- Set `LOG_LEVEL=debug` in `.env` for backend logging

## 📄 License

MIT License - see [LICENSE](LICENSE) file for details

## 🙏 Acknowledgments

- zkEngine team for the powerful zero-knowledge proof system
- Circle for programmable USDC wallets
- OpenAI for GPT-4o integration
- The Ethereum and Solana communities

## ⚠️ Important Notes

- This uses **real blockchain networks** (testnets) and **real USDC transfers**
- Always test with small amounts first
- Ensure you have testnet ETH/SOL for gas fees
- Circle API is in sandbox mode but transfers are real on testnets
- OpenAI API usage may incur costs

---

**Built with ❤️ for the future of verifiable, privacy-preserving compute**